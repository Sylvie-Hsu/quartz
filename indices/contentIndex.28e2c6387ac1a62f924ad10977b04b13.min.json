{"/":{"title":"🪴 Biubi's Drawer.","content":"\n- 💄 [Styled-Component](notes/styled-component.md)\n- 💄 [Styled-Component](notes/react.md)\n","lastmodified":"2022-12-04T12:12:28.209595525Z","tags":null},"/notes/react":{"title":"React","content":"\n### Hooks\n\n- [Introducing Hooks](https://reactjs.org/docs/hooks-intro.html)\n- [puxiao / react-hook-tutorial](https://github.com/puxiao/react-hook-tutorial)\n- [Youtube - Codevolution](https://www.youtube.com/playlist?list=PLC3y8-rFHvwisvxhZ135pogtX7_Oe3Q3A)\n- Rules of Hooks\n  - Only Call Hooks at the Top Level\n  - Only Call Hooks from React Functions\n\n#### useEffect\n\n- useEffect 执行时会建立闭包，使用 setState 时需要注意参数的值\n  [useEffect 高级用法](https://github.com/puxiao/react-hook-tutorial/blob/master/05%20useEffect%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.md)\n  \u003e 有时候，你的 effect 可能会使用一些频繁变化的值。你可能会忽略依赖列表中 state，但这通常会引起 Bug，传入空的依赖数组 []，意味着该 hook 只在组件挂载时运行一次，并非重新渲染时。但如此会有问题，在 setInterval 的回调中，count 的值不会发生变化。因为当 effect 执行时，我们会创建一个闭包，并将 count 的值被保存在该闭包当中，且初值为 0。每隔一秒，回调就会执行 setCount(0 + 1)，因此，count 永远不会超过 1。\n- 当 useEffect 闭包无法获取最新的 state 值时，可以考虑使用 useRef\n- 组件多次渲染时，在执行下一个 effect 之前，上一个 effect 会被清除\n  ```js\n  useEffect(() =\u003e {\n    const subscription = props.source.subscribe()\n    return () =\u003e {\n      // 清除订阅\n      subscription.unsubscribe()\n    }\n  })\n  ```\n- 为避免阻塞视觉更新 `useEffect` 在浏览器完成布局与绘制之后的延迟事件中调用，需绘制前同步执行可使用 `useLayoutEffect`\n\n#### useState\n\n- `setState` 为 obj 时不会 auto merge，所以需要使用扩展运算符\n  `setState(prev =\u003e { ...prev, attr: newVal })`\n\n#### useReducer\n\n- useState is built using useReducer\n- ![[Pasted image 20221031230017.png]]\n\n#### useCallback\n\n- React.memo() 确保组件只在相关 props 或 state 变化时重渲染\n\n  ```jsx\n  import React from 'react'\n\n  fuction Title () {\n  \treturn \u003ch2\u003eTitle\u003c/h2\u003e;\n  }\n\n  export default React.memo(Title)\n  ```\n\n- 组件重渲染时，内部的函数会被重新创建，所以传入函数的子组件也会因为有变化而重渲染\n- useCallback 用来 cache 依据传参而变化的函数\n\n#### useMemo\n\n- useCallback cache function, useMemo cache result of function\n\n#### useRef\n\n- 操纵 dom 变化\n- as a container to hold mutable value in global\n\n#### custom Hook\n\n- [Doc](https://zh-hans.reactjs.org/docs/hooks-custom.html)\n- 以 use 开头的函数，内部包含对其他 Hook 的调用，用于提取公共逻辑\n- 自定义 Hook 是一种重用状态逻辑的机制，调用时其中 state 和副作用完全隔离\n\n---\n\n#### 'Slot' in React = props.children\n\n```html\n// father-component \u003cLoadableBtn loading=\"{loading}\" onClick=\"{submit}\"\u003e Submit \u003c/LoadableBtn\u003e\n```\n\n```html\n// sub-component\n\u003cdiv className=\"loadable-btn-inner\"\u003e{props.children}\u003c/div\u003e\n```\n\n---\n\n#### Airbnb React/JSX Style Guide\n\n- [Doc](https://github.com/airbnb/javascript/tree/master/react)\n- propTypes and defaultProps of React component\n  ```jsx\n  // good\n  function SFC({ foo, bar, children }) {\n    return (\n      \u003cdiv\u003e\n        {foo}\n        {bar}\n        {children}\n      \u003c/div\u003e\n    )\n  }\n  SFC.propTypes = {\n    foo: PropTypes.number.isRequired,\n    bar: PropTypes.string,\n    children: PropTypes.node,\n  }\n  SFC.defaultProps = {\n    bar: \"\",\n    children: null,\n  }\n  ```\n- Filter out unnecessary props when possible\n  ```jsx\n  // good\n  render() {\n    const { irrelevantProp, ...relevantProps } = this.props;\n    return \u003cWrappedComponent {...relevantProps} /\u003e\n  }\n  ```\n","lastmodified":"2022-12-04T12:12:28.209595525Z","tags":null},"/notes/styled-component":{"title":"Styled-Component","content":"\n[styled-components doc](https://styled-components.com/docs)\n\n#### Basics\n\n- styled-component = styled React component\n  \u003e It removes the mapping between components and styles. This means that when you're defining your styles, you're actually creating a normal React component, that has your styles attached to it.\n- styled.div VS style.section\n\n  ```html\n  // styled.div\n  \u003cdiv class=\"xxx\" /\u003e\n\n  // styled.section\n  \u003csection class=\"xxx\" /\u003e\n  ```\n\n- [\"as\" polymorphic prop](https://styled-components.com/docs/api#as-polymorphic-prop)\n  实际渲染为 as={Component} 内容，但复用 WrapperComponent 样式\n\n  ```js\n  const Button = styled.button`\n    display: inline-block;\n    color: palevioletred;\n    font-size: 1em;\n    margin: 1em;\n    padding: 0.25em 1em;\n    border: 2px solid palevioletred;\n    border-radius: 3px;\n    display: block;\n  `\n\n  const ReversedButton = (props) =\u003e (\n    \u003cButton {...props} children={props.children.split(\"\").reverse()} /\u003e\n  )\n\n  render(\n    \u003cdiv\u003e\n      \u003cButton\u003eNormal Button\u003c/Button\u003e\n      \u003cButton as={ReversedButton}\u003eCustom Button with Normal Button styles\u003c/Button\u003e\n    \u003c/div\u003e,\n  )\n  ```\n\n- 在 render 函数外定义 styled-component，否则在每次 render 时都会重新创建\n  \u003e It is important to define your styled components outside of the render method, otherwise it will be recreated on every single render pass. Defining a styled component within the render method will thwart caching and drastically slow down rendering speed, and should be avoided.\n- 使用 `stylis` 预处理器，支持类 scss 语法\n- [Attaching additional props](https://styled-components.com/docs/basics#attaching-additional-props)\n\n  - attrs 中可使用函数返回结果 + 动态 props\n\n    ```js\n    const Input = styled.input.attrs((props) =\u003e ({\n      // we can define static props\n      type: \"text\",\n\n      // or we can define dynamic ones\n      size: props.size || \"1em\",\n    }))`\n      color: palevioletred;\n      font-size: 1em;\n      border: 2px solid palevioletred;\n      border-radius: 3px;\n\n      /* here we use the dynamically computed prop */\n      margin: ${(props) =\u003e props.size};\n      padding: ${(props) =\u003e props.size};\n    `\n\n    render(\n      \u003cdiv\u003e\n        \u003cInput placeholder=\"A small text input\" /\u003e\n        \u003cbr /\u003e\n        \u003cInput placeholder=\"A bigger text input\" size=\"2em\" /\u003e\n      \u003c/div\u003e,\n    )\n    ```\n\n  - attrs 可被 override，越精准优先级越高\n\n#### Advanced\n\n- Theming\n  - 可使用 Props 传参或函数，实现主题色变化或 revert\n  - 外层组件可使用 `withTheme` `useContext` `useTheme` 等方式获取 theme 信息\n- Refs\n  - 给 styled-component 传入 ref 参数可获得当前 Dom 节点或对应 React component 实例\n- Together with existing CSS\n  styled-components 生成实际的样式表并且通过 `className` 属性附加到 DOM 节点中\n  - 使用 `styled(MyComponent)` 并使用 `this.props.className` 将样式表传入 DOM 节点\n    ```js\n    class MyComponent extends React.Component {\n      render() {\n        // Attach the passed-in className to the DOM node\n        return \u003cdiv className={`some-global-class ${this.props.className}`} /\u003e\n      }\n    }\n    ```\n  - 当 styled-components 定义的样式属性与全局冲突时，由于 styled componens class 会被插入至 DOM 节点末端所以会占有较高的优先级\n  - 避免与第三方样式冲突：外层设置命名空间\n- Tagged Template Literals\n\n  - Tagged Template Literals in ES6\n\n    ```js\n    // These are equivalent:\n    fn`some string here`\n    fn([\"some string here\"])\n\n    // These are equivalent:\n    const aVar = \"good\"\n    fn`this is a ${aVar} day`\n    fn([\"this is a \", \" day\"], aVar)\n    ```\n\n  - 可以使用 \u0026\u0026 因为 styled-components 会忽略返回为 undefined, null, false, or \"\"\n    ```js\n    const Title = styled.h1`\n      /* Text centering won't break if props.upsidedown is falsy */\n      ${(props) =\u003e props.upsidedown \u0026\u0026 \"transform: rotate(180deg);\"}\n      text-align: center;\n    `\n    ```\n\n- [Referring to other components](https://styled-components.com/docs/advanced#referring-to-other-components)\n","lastmodified":"2022-12-04T12:12:28.209595525Z","tags":null}}