{"/":{"title":"🪴 Biubi's Drawer.","content":"\n- 💄 [Styled-Component](notes/styled-component.md)\n- 💄 [React](notes/react.md)\n","lastmodified":"2022-12-08T12:39:14.243853281Z","tags":null},"/notes/react":{"title":"React","content":"\n### Hooks\n- [Introducing Hooks](https://reactjs.org/docs/hooks-intro.html)\n- [puxiao / react-hook-tutorial](https://github.com/puxiao/react-hook-tutorial)\n- [Youtube - Codevolution](https://www.youtube.com/playlist?list=PLC3y8-rFHvwisvxhZ135pogtX7_Oe3Q3A)\n- Rules of Hooks\n\t- Only Call Hooks at the Top Level\n\t- Only Call Hooks from React Functions\n#### useEffect\n- useEffect 执行时会建立闭包，使用 setState 时需要注意参数的值\n\t[useEffect 高级用法](https://github.com/puxiao/react-hook-tutorial/blob/master/05%20useEffect%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.md)\n\t\u003e有时候，你的 effect 可能会使用一些频繁变化的值。你可能会忽略依赖列表中 state，但这通常会引起 Bug，传入空的依赖数组 []，意味着该 hook 只在组件挂载时运行一次，并非重新渲染时。但如此会有问题，在 setInterval 的回调中，count 的值不会发生变化。因为当 effect 执行时，我们会创建一个闭包，并将 count 的值被保存在该闭包当中，且初值为 0。每隔一秒，回调就会执行 setCount(0 + 1)，因此，count 永远不会超过 1。\n- 当 useEffect 闭包无法获取最新的 state 值时，可以考虑使用 useRef\n- 组件多次渲染时，在执行下一个 effect 之前，上一个 effect 会被清除\n\t```js\n\tuseEffect(() =\u003e {\n\t  const subscription = props.source.subscribe();\n\t  return () =\u003e {\n\t\t// 清除订阅\n\t\tsubscription.unsubscribe();\n\t  };\n\t});\n\t```\n- 为避免阻塞视觉更新 `useEffect` 在浏览器完成布局与绘制之后的延迟事件中调用，需绘制前同步执行可使用 `useLayoutEffect`\n#### useState\n- `setState` 为 obj 时不会 auto merge，所以需要使用扩展运算符\n\t`setState(prev =\u003e { ...prev, attr: newVal })`\n#### useReducer\n- useState is built using useReducer\n-  ![[Pasted image 20221031230017.png]]\n#### useCallback\n- React.memo() 确保组件只在相关 props 或 state 变化时重渲染\n\t```jsx\n\timport React from 'react'\n\t\n\tfuction Title () {\n\t\treturn \u003ch2\u003eTitle\u003c/h2\u003e;\n\t}\n\t\n\texport default React.memo(Title)\n\t```\n- 组件重渲染时，内部的函数会被重新创建，所以传入函数的子组件也会因为有变化而重渲染\n- useCallback 用来 cache 依据传参而变化的函数\n#### useMemo\n- useCallback cache function, useMemo cache result of function\n#### useRef\n- 操纵 dom 变化\n- as a container to hold mutable value in global\n#### custom Hook\n- [Doc](https://zh-hans.reactjs.org/docs/hooks-custom.html)\n- 以 use 开头的函数，内部包含对其他 Hook 的调用，用于提取公共逻辑\n- 自定义 Hook 是一种重用状态逻辑的机制，调用时其中 state 和副作用完全隔离\n---\n#### 'Slot' in React = props.children\n```html\n// father-component\n\u003cLoadableBtn loading={loading} onClick={submit}\u003e\n\tSubmit\n\u003c/LoadableBtn\u003e\n```\n\n```html\n// sub-component\n\u003cdiv className=\"loadable-btn-inner\"\u003e\n\t{props.children}\n\u003c/div\u003e\n```\n---\n#### Airbnb React/JSX Style Guide\n- [Doc](https://github.com/airbnb/javascript/tree/master/react)\n- propTypes and defaultProps of React component\n\t```jsx\n\t// good\n\tfunction SFC({ foo, bar, children }) {\n\t  return \u003cdiv\u003e{foo}{bar}{children}\u003c/div\u003e;\n\t}\n\tSFC.propTypes = {\n\t  foo: PropTypes.number.isRequired,\n\t  bar: PropTypes.string,\n\t  children: PropTypes.node,\n\t};\n\tSFC.defaultProps = {\n\t  bar: '',\n\t  children: null,\n\t};\n\t```\n- Filter out unnecessary props when possible\n\t```jsx\n\t// good\n\trender() {\n\t  const { irrelevantProp, ...relevantProps } = this.props;\n\t  return \u003cWrappedComponent {...relevantProps} /\u003e\n\t}\n\t```","lastmodified":"2022-12-08T12:39:14.243853281Z","tags":null},"/notes/styled-component":{"title":"Styled-Component","content":"\n[styled-components doc](https://styled-components.com/docs)\n\n#### Basics\n- styled-component  = styled React component\n\t\u003eIt removes the mapping between components and styles. This means that when you're defining your styles, you're actually creating a normal React component, that has your styles attached to it.\n- styled.div VS style.section\n\t```html\n\t// styled.div\n\t\u003cdiv class=\"xxx\"/\u003e\n\t\n\t// styled.section\n\t\u003csection class=\"xxx\" /\u003e\n\t```\n- [\"as\" polymorphic prop](https://styled-components.com/docs/api#as-polymorphic-prop)\n\t实际渲染为 as={Component} 内容，但复用 WrapperComponent 样式\n\t```js\n\tconst Button = styled.button`\n\t  display: inline-block;\n\t  color: palevioletred;\n\t  font-size: 1em;\n\t  margin: 1em;\n\t  padding: 0.25em 1em;\n\t  border: 2px solid palevioletred;\n\t  border-radius: 3px;\n\t  display: block;\n\t`;\n\t\n\tconst ReversedButton = props =\u003e \u003cButton {...props} children={props.children.split('').reverse()} /\u003e\n\t\n\trender(\n\t  \u003cdiv\u003e\n\t\t\u003cButton\u003eNormal Button\u003c/Button\u003e\n\t\t\u003cButton as={ReversedButton}\u003eCustom Button with Normal Button styles\u003c/Button\u003e\n\t  \u003c/div\u003e\n\t);\n\t```\n- 在 render 函数外定义 styled-component，否则在每次 render 时都会重新创建\n\t\u003eIt is important to define your styled components outside of the render method, otherwise it will be recreated on every single render pass. Defining a styled component within the render method will thwart caching and drastically slow down rendering speed, and should be avoided.\n- 使用 `stylis` 预处理器，支持类 scss 语法\n- [Attaching additional props](https://styled-components.com/docs/basics#attaching-additional-props)\n\t- attrs 中可使用函数返回结果 + 动态 props\n\t\t```js\n\t\tconst Input = styled.input.attrs(props =\u003e ({\n\t\t  // we can define static props\n\t\t  type: \"text\",\n\t\t\n\t\t  // or we can define dynamic ones\n\t\t  size: props.size || \"1em\",\n\t\t}))`\n\t\t  color: palevioletred;\n\t\t  font-size: 1em;\n\t\t  border: 2px solid palevioletred;\n\t\t  border-radius: 3px;\n\t\t\n\t\t  /* here we use the dynamically computed prop */\n\t\t  margin: ${props =\u003e props.size};\n\t\t  padding: ${props =\u003e props.size};\n\t\t`;\n\t\t\n\t\trender(\n\t\t  \u003cdiv\u003e\n\t\t    \u003cInput placeholder=\"A small text input\" /\u003e\n\t\t    \u003cbr /\u003e\n\t\t    \u003cInput placeholder=\"A bigger text input\" size=\"2em\" /\u003e\n\t\t  \u003c/div\u003e\n\t\t);\n\t\t```\n\t- attrs 可被 override，越精准优先级越高\n\n#### Advanced\n- Theming\n\t- 可使用 Props 传参或函数，实现主题色变化或 revert\n\t- 外层组件可使用 `withTheme` `useContext` `useTheme` 等方式获取 theme 信息\n- Refs\n\t- 给 styled-component 传入 ref 参数可获得当前 Dom 节点或对应 React component 实例\n- Together with existing CSS\n\tstyled-components 生成实际的样式表并且通过 `className` 属性附加到 DOM 节点中\n\t- 使用 `styled(MyComponent)` 并使用 `this.props.className` 将样式表传入 DOM 节点\n\t\t```js\n\t\tclass MyComponent extends React.Component {\n\t\t  render() {\n\t\t    // Attach the passed-in className to the DOM node\n\t\t    return \u003cdiv className={`some-global-class ${this.props.className}`} /\u003e\n\t\t  }\n\t\t}\n\t\t```\n\t- 当 styled-components 定义的样式属性与全局冲突时，由于 styled componens class 会被插入至 DOM 节点末端所以会占有较高的优先级\n\t- 避免与第三方样式冲突：外层设置命名空间\n- Tagged Template Literals\n\t- Tagged Template Literals in ES6\n\t\t```js\n\t\t// These are equivalent:\n\t\tfn`some string here`;\n\t\tfn(['some string here']);\n\t\t\n\t\t// These are equivalent:\n\t\tconst aVar = 'good';\n\t\tfn`this is a ${aVar} day`;\n\t\tfn(['this is a ', ' day'], aVar);\n\t\t```\n\t- 可以使用 \u0026\u0026 因为 styled-components 会忽略返回为 undefined, null, false, or \"\"\n\t\t```js\n\t\tconst Title = styled.h1`\n\t\t  /* Text centering won't break if props.upsidedown is falsy */\n\t\t  ${props =\u003e props.upsidedown \u0026\u0026 'transform: rotate(180deg);'}\n\t\t  text-align: center;\n\t\t`;\n\t\t```\n- [Referring to other components](https://styled-components.com/docs/advanced#referring-to-other-components)","lastmodified":"2022-12-08T12:39:14.247853333Z","tags":null}}