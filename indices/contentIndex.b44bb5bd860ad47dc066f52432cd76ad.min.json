{"/":{"title":"🪴 Biubi's Drawer.","content":"\n- 💄 [Styled-Component](notes/styled-component.md)\n- 🍾 [React](notes/react.md)\n- 🌍 [THE METAVERSE And How It Will Revolutionize Everything](notes/the-metaverse.md)\n","lastmodified":"2022-12-08T13:10:31.577440476Z","tags":null},"/notes/react":{"title":"React","content":"\n## Hooks\n- [Introducing Hooks](https://reactjs.org/docs/hooks-intro.html)\n- [puxiao / react-hook-tutorial](https://github.com/puxiao/react-hook-tutorial)\n- [Youtube - Codevolution](https://www.youtube.com/playlist?list=PLC3y8-rFHvwisvxhZ135pogtX7_Oe3Q3A)\n- Rules of Hooks\n\t- Only Call Hooks at the Top Level\n\t- Only Call Hooks from React Functions\n#### useEffect\n- useEffect 执行时会建立闭包，使用 setState 时需要注意参数的值\n\t[useEffect 高级用法](https://github.com/puxiao/react-hook-tutorial/blob/master/05%20useEffect%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.md)\n\t\u003e有时候，你的 effect 可能会使用一些频繁变化的值。你可能会忽略依赖列表中 state，但这通常会引起 Bug，传入空的依赖数组 []，意味着该 hook 只在组件挂载时运行一次，并非重新渲染时。但如此会有问题，在 setInterval 的回调中，count 的值不会发生变化。因为当 effect 执行时，我们会创建一个闭包，并将 count 的值被保存在该闭包当中，且初值为 0。每隔一秒，回调就会执行 setCount(0 + 1)，因此，count 永远不会超过 1。\n- 当 useEffect 闭包无法获取最新的 state 值时，可以考虑使用 useRef\n- 组件多次渲染时，在执行下一个 effect 之前，上一个 effect 会被清除\n\t```js\n\tuseEffect(() =\u003e {\n\t  const subscription = props.source.subscribe();\n\t  return () =\u003e {\n\t\t// 清除订阅\n\t\tsubscription.unsubscribe();\n\t  };\n\t});\n\t```\n- 为避免阻塞视觉更新 `useEffect` 在浏览器完成布局与绘制之后的延迟事件中调用，需绘制前同步执行可使用 `useLayoutEffect`\n#### useState\n- `setState` 为 obj 时不会 auto merge，所以需要使用扩展运算符\n\t`setState(prev =\u003e { ...prev, attr: newVal })`\n#### useReducer\n- useState is built using useReducer\n-  ![react-useStatevsuseReducer.png](/content/notes/images/react-useStatevsuseReducer.png)\n#### useCallback\n- React.memo() 确保组件只在相关 props 或 state 变化时重渲染\n\t```jsx\n\timport React from 'react'\n\t\n\tfuction Title () {\n\t\treturn \u003ch2\u003eTitle\u003c/h2\u003e;\n\t}\n\t\n\texport default React.memo(Title)\n\t```\n- 组件重渲染时，内部的函数会被重新创建，所以传入函数的子组件也会因为有变化而重渲染\n- useCallback 用来 cache 依据传参而变化的函数\n#### useMemo\n- useCallback cache function, useMemo cache result of function\n#### useRef\n- 操纵 dom 变化\n- as a container to hold mutable value in global\n#### custom Hook\n- [Doc](https://zh-hans.reactjs.org/docs/hooks-custom.html)\n- 以 use 开头的函数，内部包含对其他 Hook 的调用，用于提取公共逻辑\n- 自定义 Hook 是一种重用状态逻辑的机制，调用时其中 state 和副作用完全隔离\n---\n#### 'Slot' in React = props.children\n```html\n// father-component\n\u003cLoadableBtn loading={loading} onClick={submit}\u003e\n\tSubmit\n\u003c/LoadableBtn\u003e\n```\n\n```html\n// sub-component\n\u003cdiv className=\"loadable-btn-inner\"\u003e\n\t{props.children}\n\u003c/div\u003e\n```\n---\n#### Airbnb React/JSX Style Guide\n- [Doc](https://github.com/airbnb/javascript/tree/master/react)\n- propTypes and defaultProps of React component\n\t```jsx\n\t// good\n\tfunction SFC({ foo, bar, children }) {\n\t  return \u003cdiv\u003e{foo}{bar}{children}\u003c/div\u003e;\n\t}\n\tSFC.propTypes = {\n\t  foo: PropTypes.number.isRequired,\n\t  bar: PropTypes.string,\n\t  children: PropTypes.node,\n\t};\n\tSFC.defaultProps = {\n\t  bar: '',\n\t  children: null,\n\t};\n\t```\n- Filter out unnecessary props when possible\n\t```jsx\n\t// good\n\trender() {\n\t  const { irrelevantProp, ...relevantProps } = this.props;\n\t  return \u003cWrappedComponent {...relevantProps} /\u003e\n\t}\n\t```","lastmodified":"2022-12-08T13:10:31.581440494Z","tags":null},"/notes/styled-component":{"title":"Styled-Component","content":"\n[styled-components doc](https://styled-components.com/docs)\n\n## Basics\n- styled-component  = styled React component\n\t\u003eIt removes the mapping between components and styles. This means that when you're defining your styles, you're actually creating a normal React component, that has your styles attached to it.\n- styled.div VS style.section\n\t```html\n\t// styled.div\n\t\u003cdiv class=\"xxx\"/\u003e\n\t\n\t// styled.section\n\t\u003csection class=\"xxx\" /\u003e\n\t```\n- [\"as\" polymorphic prop](https://styled-components.com/docs/api#as-polymorphic-prop)\n\t实际渲染为 as={Component} 内容，但复用 WrapperComponent 样式\n\t```js\n\tconst Button = styled.button`\n\t  display: inline-block;\n\t  color: palevioletred;\n\t  font-size: 1em;\n\t  margin: 1em;\n\t  padding: 0.25em 1em;\n\t  border: 2px solid palevioletred;\n\t  border-radius: 3px;\n\t  display: block;\n\t`;\n\t\n\tconst ReversedButton = props =\u003e \u003cButton {...props} children={props.children.split('').reverse()} /\u003e\n\t\n\trender(\n\t  \u003cdiv\u003e\n\t\t\u003cButton\u003eNormal Button\u003c/Button\u003e\n\t\t\u003cButton as={ReversedButton}\u003eCustom Button with Normal Button styles\u003c/Button\u003e\n\t  \u003c/div\u003e\n\t);\n\t```\n- 在 render 函数外定义 styled-component，否则在每次 render 时都会重新创建\n\t\u003eIt is important to define your styled components outside of the render method, otherwise it will be recreated on every single render pass. Defining a styled component within the render method will thwart caching and drastically slow down rendering speed, and should be avoided.\n- 使用 `stylis` 预处理器，支持类 scss 语法\n- [Attaching additional props](https://styled-components.com/docs/basics#attaching-additional-props)\n\t- attrs 中可使用函数返回结果 + 动态 props\n\t\t```js\n\t\tconst Input = styled.input.attrs(props =\u003e ({\n\t\t  // we can define static props\n\t\t  type: \"text\",\n\t\t\n\t\t  // or we can define dynamic ones\n\t\t  size: props.size || \"1em\",\n\t\t}))`\n\t\t  color: palevioletred;\n\t\t  font-size: 1em;\n\t\t  border: 2px solid palevioletred;\n\t\t  border-radius: 3px;\n\t\t\n\t\t  /* here we use the dynamically computed prop */\n\t\t  margin: ${props =\u003e props.size};\n\t\t  padding: ${props =\u003e props.size};\n\t\t`;\n\t\t\n\t\trender(\n\t\t  \u003cdiv\u003e\n\t\t    \u003cInput placeholder=\"A small text input\" /\u003e\n\t\t    \u003cbr /\u003e\n\t\t    \u003cInput placeholder=\"A bigger text input\" size=\"2em\" /\u003e\n\t\t  \u003c/div\u003e\n\t\t);\n\t\t```\n\t- attrs 可被 override，越精准优先级越高\n\n## Advanced\n- Theming\n\t- 可使用 Props 传参或函数，实现主题色变化或 revert\n\t- 外层组件可使用 `withTheme` `useContext` `useTheme` 等方式获取 theme 信息\n- Refs\n\t- 给 styled-component 传入 ref 参数可获得当前 Dom 节点或对应 React component 实例\n- Together with existing CSS\n\tstyled-components 生成实际的样式表并且通过 `className` 属性附加到 DOM 节点中\n\t- 使用 `styled(MyComponent)` 并使用 `this.props.className` 将样式表传入 DOM 节点\n\t\t```js\n\t\tclass MyComponent extends React.Component {\n\t\t  render() {\n\t\t    // Attach the passed-in className to the DOM node\n\t\t    return \u003cdiv className={`some-global-class ${this.props.className}`} /\u003e\n\t\t  }\n\t\t}\n\t\t```\n\t- 当 styled-components 定义的样式属性与全局冲突时，由于 styled componens class 会被插入至 DOM 节点末端所以会占有较高的优先级\n\t- 避免与第三方样式冲突：外层设置命名空间\n- Tagged Template Literals\n\t- Tagged Template Literals in ES6\n\t\t```js\n\t\t// These are equivalent:\n\t\tfn`some string here`;\n\t\tfn(['some string here']);\n\t\t\n\t\t// These are equivalent:\n\t\tconst aVar = 'good';\n\t\tfn`this is a ${aVar} day`;\n\t\tfn(['this is a ', ' day'], aVar);\n\t\t```\n\t- 可以使用 \u0026\u0026 因为 styled-components 会忽略返回为 undefined, null, false, or \"\"\n\t\t```js\n\t\tconst Title = styled.h1`\n\t\t  /* Text centering won't break if props.upsidedown is falsy */\n\t\t  ${props =\u003e props.upsidedown \u0026\u0026 'transform: rotate(180deg);'}\n\t\t  text-align: center;\n\t\t`;\n\t\t```\n- [Referring to other components](https://styled-components.com/docs/advanced#referring-to-other-components)","lastmodified":"2022-12-08T13:10:31.581440494Z","tags":null},"/notes/the-metaverse":{"title":"React","content":"\n## 01 什么是元宇宙\n\n“元宇宙”一词最早出现在小说《雪崩》中，但并未被明确定义。目前已经从科幻小说范畴转变成为消费者的真实行为和企业技术的发展前沿。\n\n---\n\n\u003e 目前，人们预测元宇宙会是一个“企业互联网”。互联网的非营利性质和早期历史源于这样一个事实：政府发起的研究型实验室和大学实际上是唯一拥有计算人才、资源和建立“网络的网络”这一宏大目标的机构，而在营利性部门中很少有人理解其商业潜力。但对于元宇宙来说，情况大不相同，而且恰恰相反，它是由私人企业开创和建立的，它的目标很明确，那就是提供商业服务、收集数据、出售广告位和销售虚拟产品。\n\u003e \n\n如果发源于私人企业所拥有的产品，元宇宙或许会成为比Web2更资本导向盈利至上的平台。\n\n---\n\n目前各方对元宇宙的定义和所能涵盖的领域难以达成共识，同时基于递归革新（Recursive Innovation）的特点，元宇宙也很难被预测。\n\n\u003e 递归革新：技术转型之所以难以预测，就在于它不是由任何一项发明、创新或个人推动的，而是许多变化共同作用的结果。在一项新技术诞生后，社会和个人发明者会对它做出反应，从而产生新的行为和新的产品，这反过来又导致了基础技术新的用例，从而激发了更多新的行为和创造，如此往复。\n\u003e \n\n---\n\n作者对元宇宙的定义:\n\n\u003e 大规模、可互操作的网络，能够实时渲染3D虚拟世界，借助大量连续性数据，如身份、历史、权利、对象、通信和支付等，可以让无限数量的用户体验实时同步和持续有效的在场感。\n\u003e \n- 互操作性：统一的传输标准，不同系统或软件间需要具备标准化的可通信能力，用于身份识别、数字支付等\n- 大规模扩展：超出现实世界的多样性\n- 持续性挑战：虚拟世界需要具有持续性历史，即记录发生过的事情并对未来造成影响，而不能像游戏中一样简单对某一关卡进行重置，也因此需要更多计算和存储资源\n- 同步性：成为能共享的体验，需要能够提供高带宽、低延迟和连续性连接的基础设施\n- 无限用户：要求软硬件能够承载更大并发量\n\n---\n\n元宇宙和Web3概念的区分：\n\n- Web3：基于区块链的当今互联网的去中心化版本\n- 元宇宙：大规模的具备持续性同步性的虚拟世界\n\n## 02 如何构建元宇宙\n\n- 网络：元宇宙中需要达到超低延迟或0延迟，目前基础设施还难以实现。\n- 计算\n    - 目前已有计算能力难以满足所需，”计算效率需要提升至目前的1000倍“。\n    - 远程渲染（云服务器）的技术方式仍然受到网络延迟的限制。\n        \n        \u003e 斯威尼定律：本地计算的提升将继续超过网络带宽、延迟和可靠性的提升。\n        \u003e \n    - 去中心化计算的愿景：用户通过出售设备空闲算力获得代币补偿。\n- 虚拟世界引擎\n    - 虚拟引擎：Unity、Unreal等\n    - 虚拟世界集成平台（Integrated Virtual World Platforms，IVWP）：以通用、跨平台游戏引擎建立，能够使用户自主创建自己的虚拟世界，比如Roblox、《我的世界》和《堡垒之夜》创意模式。该模式被认为是构建元宇宙更简单、更好的路径。\n- 互操作性：行业内需要通用标准及数据共享模式。\n- 硬件\n- 支付方式：在虚拟世界平台中的产品普遍需要支付30%佣金，元宇宙建成需要寻找方式突破这一限制。\n- 区块链\n    - 定义：由一个去中心化的“验证者”网络所管理的数据库\n        - Dapp：不私有存储用户数据的App（数据存于链上）\n            - 产品能否吸引用户不在于数据壁垒而在于功能设计本身\n        - NFT：虚拟商品所有权 \u0026\u0026 不受限制的转售权\n            - 只有当游戏广泛支持基于区块链的交易时才具有实际价值\n        - DAO：采用智能合约持续管理组织行政工作，包括所有权的分配、章程投票的计算、收益的分配等\n            - 区块链技术下延伸出的一种新的组织管理与经济奖励模型？\n    - 价值：相比Web2开源社区的为爱发电，区块链能够提供新的更为民主公平的经济模型持续奖励为社区成功做出贡献的人，从而颠覆封闭平台所占有的优势。\n    - 缺陷：昂贵和缓慢\n    \n    \u003e 在区块链中炒作的成分占多少，已实现的部分或未来有可能实现的部分占多少，仍然不确定——这与元宇宙的当前状态没什么不同。然而，计算时代的一个核心经验就是：能为开发人员和用户提供最优服务的平台将会胜出。区块链还有很长的路要走，但许多人认为，随着元宇宙经济的增长，它们的不可更改性和透明性是确保这两个群体的利益得到优先考虑的最佳方式。\n    \u003e \n\n## 03 元宇宙如何彻底改变一切\n\n下一个可能助推元宇宙的关键部分是什么？\n\n- 基础技术的逐年改进\n    - 互联网服务、计算能力、游戏引擎、加密运动、经济激励等\n- 正在进行的代际变革：新时代出生的数字原住民\n\n---\n\n\u003e 鲍莫尔成本病（Baumol’s Cost Disease）：较高劳动生产率的工作的工资上涨，会带动那些生产率增长较慢的工作的工资上涨。\n\u003e \n\n---\n\n\u003e 颠覆并不是一个线性的过程，而是一个递归且不可预测的过程。\n\u003e","lastmodified":"2022-12-08T13:10:31.581440494Z","tags":null}}